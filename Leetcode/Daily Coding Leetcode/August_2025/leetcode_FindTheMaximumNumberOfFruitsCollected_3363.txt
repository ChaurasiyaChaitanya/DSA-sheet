class Solution {
    private static final int intMax = Integer.MAX_VALUE;
    private int[][] dp;
    private List<int[]> dirs;

    public int maxCollectedFruits(int[][] fruits) {
        int n = fruits.length;

        long first = 0;
        for(int i=0; i<n; i++) {
            first += fruits[i][i];
        }

        dirs = Arrays.asList(new int[]{1, -1}, new int[]{1, 0}, new int[]{1, 1});

        dp = new int[n][n];
        for(int[] row : dp) {
            Arrays.fill(row, -1);
        }

        int second = dfs(0, n-1, n-1, n, fruits);

        dirs = Arrays.asList(new int[]{-1, 1}, new int[]{0, 1}, new int[]{1, 1});

        for(int[] row : dp) {
            Arrays.fill(row, -1);
        }

        int third = dfs(n-1, 0, n-1, n, fruits);

        return (int) (first + second + third);
    }

    private int dfs(int row, int col, int moves, int n, int[][] fruits) {
        if (row == n - 1 && col == n - 1) {
            return (moves == 0) ? 0 : intMax;
        }

        if (moves == 0 || row == col) {
            return intMax;
        }
        
        if (dp[row][col] != -1) {
            return dp[row][col];
        }

        long best = -1;

        for (int[] d : dirs) {
            int nr = row + d[0], nc = col + d[1];
            if (nr >= 0 && nr < n && nc >= 0 && nc < n) {
                int val = dfs(nr, nc, moves - 1, n, fruits);
                if (val != intMax) {
                    best = Math.max(best, (long) val);
                }
            }
        }

        int result = (best < 0 ? intMax : fruits[row][col] + (int) best);
        dp[row][col] = result;

        return result;
    }
}